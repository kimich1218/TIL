# 트랜잭션 격리수준
트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트래잭션 끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다. 즉, 특정 트랜잭션이 다른 트랜잭션의 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 격리 수준은 크게 4가지로 나뉜다.

- READ UNCOMMITTED
* READ COMMITTED
* REPEATABLE READ
* SERIALIZABLE

아래로 내려갈수록 고립 정도가 높아지며 성능은 떨어지게 된다. 일반적으로 READ COMMITTED 또는 REPEATABLE READ가 사용된다.

문제점
- **Dirty Read**: 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있어, 해당 트랜잭션이 롤백될 경우 잘못된 데이터를 읽게 되는 문제.
- **Non-Repeatable Read**: 한 트랜잭션이 동일한 데이터를 반복해서 읽을 때, 그 사이에 다른 트랜잭션이 데이터를 수정하면 결과가 다르게 나오는 문제.
* **Phantom Read**: 한 트랜잭션 동안 동일한 쿼리를 여러 번 실행할 때, 그 사이에 다른 트랜잭션이 데이터를 삽입하거나 삭제하면 결과 집합이 달라지는 문제.


#### READ UNCOMMITTED
어떤 트랜잭션이 COMMIT 또는 ROLLBACK을 하지 않아도 변경된 데이터를 읽는 가장 낮은 격리 수준이다. Dirdy Read, Non-Repeatable Read, Phantom Read의 문제가 발생할 수 있다.

**예시**
- 상황: 트랜잭션 A는 10번 사원의 나이를 27살에서 28살로 변경했지만 아직 **커밋**하지 않았다.
- 트랜잭션 A: 10번 사원의 나이를 27살에서 28살로 변경.
- 트랜잭션 B: 10번 사원의 나이를 조회.
  * 조회 값: 28살 (커밋되지 않은 데이터를 읽음).
* 트랜잭션 A: 이후 롤백.
* 트랜잭션 B: 다시 10번 사원의 나이를 조회.
  * 조회 값: 27살 (원래 값).

결과: 트랜잭션 B가 커밋되지 않은 데이터를 읽는 문제가 발생함. 나중에 트랜잭션 A가 롤백되면 트랜잭션 B는 잘못된 데이터를 기반으로 작업하게 된다.

#### READ COMMITTED
커밋된 데이터만이 읽을 수 있는 수준이다. 아짓 커밋되지 않은 데이터를 읽는 것을 할 수 없으므로 Dirty Read 문제는 발생하지 않는다. 하지만 Non-Repeatable Read, Phantom Read 문제는 발생 할 수 있다.

**예시**
- 상황: 트랜잭션 A는 10번 사원의 나이를 27살에서 28살로 변경하고 커밋했다.
- 트랜잭션 A: 10번 사원의 나이를 27살에서 28살로 변경하고 커밋.
* 트랜잭션 B: 10번 사원의 나이를 조회.
  * 조회 값: 27살 (트랜잭션 A의 커밋 전에 조회).
* 트랜잭션 B: 10번 사원의 나이를 다시 조회.
  * 조회 값: 28살 (트랜잭션 A의 커밋 후 조회).

결과: Dirty Read는 발생하지 않지만, 트랜잭션 B가 한 번의 조회에서 27살을 보고, 이후 다시 조회할 때 28살을 보는 Non-Repeatable Read 문제가 발생함.

#### REPEATABLE READ 
트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다. 트랜잭션이 시작되면, 트랜잭션이 끝날 때까지 동일한 데이터는 다른 트랜잭션에 의해 수정되거나 삭제 될 수 없다. Phanton Read를 발생 시킬 수 있다.

**예시**
- 상황: 트랜잭션 A는 10번 사원의 나이를 27살에서 28살로 변경하고 커밋했다.
- 트랜잭션 A: 10번 사원의 나이를 27살에서 28살로 변경하고 커밋.
* 트랜잭션 B: 10번 사원의 나이를 조회.
  * 조회 값: 27살 (트랜잭션 시작 시점의 데이터).
* 트랜잭션 B: 10번 사원의 나이를 다시 조회.
  * 조회 값: 27살 (트랜잭션 시작 시점의 데이터가 유지됨).

결과: Non-Repeatable Read는 발생하지 않음. 트랜잭션 B는 시작 시점에 읽었던 27살 값을 끝까지 읽는다. 그러나 다른 트랜잭션에서 새로운 데이터를 삽입하거나 삭제할 경우 Phantom Read가 발생할 수 있다.

#### SERIALIZABLE
가장 높은 격리 수준으로, 트랜잭션들이 완벽히 직렬화되어 실행된다. 하나의 트랜잭션이 끝날때까지 다른 트랜잭션은 그 데이터에 접근 할 수 없다. 읽기 작업까지 잠금을 걸어서 다른 트랜잭션이 그 데이터를 읽지 못하게 한다.

**예시**
- 상황: 트랜잭션 A는 10번 사원의 나이를 27살에서 28살로 변경하고 커밋했다.
- 트랜잭션 A: 10번 사원의 나이를 27살에서 28살로 변경하려고 시도.
* 트랜잭션 B: 10번 사원의 나이를 조회하려고 시도.
  * 조회 실패: 트랜잭션 A가 끝날 때까지 트랜잭션 B는 대기 상태로 남음.
* 트랜잭션 A: 10번 사원의 나이를 28살로 변경하고 커밋.
* 트랜잭션 B: 10번 사원의 나이를 조회.
  * 조회 값: 28살.

결과: 트랜잭션 A가 완료될 때까지 트랜잭션 B는 데이터를 읽을 수 없음. Dirty Read, Non-Repeatable Read, Phantom Read 문제가 모두 발생하지 않음. 그러나 성능 저하가 발생함.

