# 페이징을 통한 가상 메모리 관리

프로세스에 연속적인 메모리 공간을 할당하는 방식을 연속 메모리 할당 방식이라고 한다. 이러한 방식으로 할당 할 때 고려해야 할 사항과 잠재적인 문제점이 있다.

#### 스와핑
메모리에 적재된 프로세스들 중에 사용하지 않는 프로세스가 있을 수 있다. 이러한 프로세스들을 임시로 보조기억장치로 밀어내고 새로 생긴 공간에 다른 프로세스를 적재여 실행하는 방식을 **스와핑**이라고 한다.

#### 메모리 할당
프로세스는 메모리 내에서 빈 공간에 적재되어야 하며 만약 빈 공간이 여러 개 있다면 프로세스를 어디에 배치해야 할까? 3가지 방식이 적재 방식이 있다.

- 최초 적합
  - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.
  - 프로세스가 적재될 공간을 발견하는 즈기 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 빠른 할당이 가능하다.
- 최적 적합
  - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.
- 최악 적합
  - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세그가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.

#### 외부 단편화
연속 메모리의 할당으로 외부 단편화라는 문제를 발생시킬 수 있다. 
![](https://github-production-user-asset-6210df.s3.amazonaws.com/82080962/374926175-ba8d6349-a862-4fb3-bf20-380b700d5e4b.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20241009%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241009T105422Z&X-Amz-Expires=300&X-Amz-Signature=22f5118e00a8640077e9e2560a51eb4e28308c3883fd786af88ba7109d40bfd6&X-Amz-SignedHeaders=host)<!-- {"width":393} -->
프로세스 B와 프로세스 D의 실행이 완료되면 더 이상 메모리에 남아 있지 않게 된다. 그 만큼 빈 공간이 생기게 된다. 

현재 남아 있는 메모리 공간은 34KB이지만 실제로는 18KB 이상의 프로세스를 적재할 수 없다. 즉, 이러한 현상때문에 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 외부 단편화 라고 한다.

어러한 문제를 해결하기 위한 방안으로 메모리를 압축하는 방법이 있다. 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 하나의 큰 빈 공간을 만드는 방식이다. 하지만 빈 공간들을 모으는 과정에서 현재 실행 중인 프로세스를 모두 멈추고야 한다. 이로 인해 오버해드가 발생하게 되어 좋은 방안은 아니다. 또 다른 해결 방안은 페이징 기법을 활용하는 것이다.

#### 페이징
페이징은 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
![](https://github-production-user-asset-6210df.s3.amazonaws.com/82080962/374926220-83dabdb6-1a6a-432d-9a43-2f5cf33d4cd5.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20241009%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241009T105533Z&X-Amz-Expires=300&X-Amz-Signature=04dd8cd3c59c2f01f5b5f4d0e424718da92b419ee7910d115aa823bf934c55eb&X-Amz-SignedHeaders=host)<!-- {"width":413} -->

#### 테이플 페이지
프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서는 순차적을 프로세스를 실행할 수 없다. 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 페이지 테이플을 이용한다.
![](https://github-production-user-asset-6210df.s3.amazonaws.com/82080962/374926247-9a8e43b7-8a69-4822-957c-14bae0851414.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20241009%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241009T105557Z&X-Amz-Expires=300&X-Amz-Signature=776cb0129e09c9656b8532bd6f61176c601a7611732b2755d430a5eb30fc6b6a&X-Amz-SignedHeaders=host)<!-- {"width":543} -->

****페이지 테이블 베이스 레지스터(PTBR: Page Table Base Register)****

프로세스는 각자의 페이지 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. 그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가지고 있다.

하지만 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어나는 단점이 있다. 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 한번, 총 두 번의 메모리 접근이 필요로 하게 된다.

이와 같은 문제를 해결하기 위해 **TLB**라는 페이지 테이블의 캐시 메모리를 둔다. TLB는 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다. 