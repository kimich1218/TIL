# JVM의 내부 구조(클래스 로더, 실행엔진)
JVM의 구조는 다음과 같이 구성되어 있다.
![](https://github-production-user-asset-6210df.s3.amazonaws.com/82080962/371750601-81da04e7-62ee-42f5-aa9a-eafa08a77970.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20240928%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240928T103150Z&X-Amz-Expires=300&X-Amz-Signature=eb1dfbe98e7ec23ca05b4ac5344b0f1fb2021e4e2a8d2fb73d98f6810d8c84c8&X-Amz-SignedHeaders=host)<!-- {"width":483} -->
클래스 로드, 실행엔진, 런타임 데이터 영역으로 나눠진다. 실행엔진에는 인터프리터, JIT 컴파일러, 가비지 콜렉터로 구성되어있다. 런타임 메모리 영역은 메소드 영역, 힙 영역, PC Register, 스택 영역, 네이티브 메소드로 나뉜다. 각각의 영역에 대해 알아보도록 하자.

#### 클래스 로더
클래스 로더는 자바 컴파일러를 통해서 자바 바이트 코드를 변경된 코드를 동적으로 로드하고, 링크를 통해 배치하는 작업을 하는 모듈이다. 바이트코드를 런타임 메모리 영역으로 배치한다. 모든 메모리를 한 번에 올리지 않고, 어플리케이션에 필요한 메모리만 적재한다.
- Loading: 클래스 파일을 JVM의 메모리에 로드한다.
- Linking: 클래스 파일을 검증한다.
- Initialization: 클래스 변수들을 적절한 값으로 초기화 한다.

#### 실행 엔진
실행 엔진은 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다. 자바 바이트코드는 기계어가 읽을 수 있는 언어가 아닌 자바 가상머신이 이해할 수 있는 중간단계의 코드이다. 실행 엔진은 이러한 바이트 코드를 실제로 JVM 내부에서 기계가 실행 할 수 있도록 변경해준다. 이러한 수행 과정에서 인터프리터 방식과 JIT 컴파일러 방식을 혼용해서 바이트 코드를 실행한다. 

인터프리터는 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행한다. JVM은 기본적으로 인터프리터 방식으로 동작을 하였지만 같은 메소드를 반복적으로 호출이 될 수 있어서 속도가 느리다는 단점이 있었다. 이러한 단점을 해결하기 위해 JIT 컴파일러를 도입하기 시작했다.

JIT 컴파일러는 이러한 인터프리터 방식의 단점을 해결하기 위한 컴파일러 방식이다. 바이트 코드 전체를 컴파일하여 네이티브 코드를 변경하고 이후에는 더 이상 인터프리팅하지 않고 캐싱을 활용하여 네이티브 코드로 직접 실행하는 방식이다. 하지만 네이티브 코드로 변환하는데 비용이 발생하기 때문에 JVM은 모든 코드를 컴파일 하는 것이 아닌 자주 사용되는 코드를 측정하고 일정 기준치가 넘어가면 그 때 JIT 컴파일러를 실행한다.

